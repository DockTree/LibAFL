#[cfg(target_os = "linux")]
use std::{
    env,
};
use std::fs::File;
use std::io::{Read};
use libafl_qemu::{
    Emulator, command::NopCommandManager, NopEmulatorDriver, NopSnapshotManager, Qemu, EmulatorModules, Hook, modules::{EmulatorModuleTuple, EmulatorModule}, SyscallHookResult, GuestAddr, SYS_read, 
};
use libafl::{
    inputs::{BytesInput, HasTargetBytes}, executors::ExitKind,
};
use libafl_bolts::{
    tuples::tuple_list,
    AsSlice,
};
//use libafl_targets::forkserver::{map_shared_memory, start_forkserver, };

pub const MAX_INPUT_SIZE: usize = 1048576;

#[derive(Default, Clone, Debug)]
struct QemuInputHelper {
    /// initially, the buffer generated by calling BytesInput.target_bytes(). on successive calls
    /// to `SYS_read`, the vector will shrink as bytes are passed from this buffer to the buffer
    /// specified in the syscall
    bytes: Vec<u8>,
}

impl QemuInputHelper {
    /// given an address to use as the address for an mmap'd file, create a new
    /// QemuFilesystemBytesHelper  
    fn new(bytes: Vec<u8>) -> Self {
        Self {
            bytes,
            ..Default::default()
        }
    }
}

#[expect(clippy::too_many_arguments)]
#[allow(clippy::needless_pass_by_value)] // no longer a problem with nightly
fn syscall_hook<ET, I, S>(
    // Our instantiated [`EmulatorModules`]
    qemu: Qemu,
    emulator_modules: &mut EmulatorModules<ET, I, S>,
    _state: Option<&mut S>,
    // Syscall number
    syscall: i32,
    // Registers
    x0: GuestAddr,
    x1: GuestAddr,
    x2: GuestAddr,
    _x3: GuestAddr,
    _x4: GuestAddr,
    _x5: GuestAddr,
    _x6: GuestAddr,
    _x7: GuestAddr,
) -> SyscallHookResult
where
    ET: EmulatorModuleTuple<I, S>,
    I: Unpin,
    S: Unpin,
{
    let syscall = syscall as i64;

    if syscall == SYS_read && x0 == 0 {
        let input: &mut QemuInputHelper = emulator_modules.modules_mut().match_first_type_mut::<QemuInputHelper>().unwrap();
        let clen = input.bytes.len();
        let offset: usize = if x2 == 0{
            0
        } else if x2 as usize <= clen {
            x2.try_into().unwrap()
        } else {
            clen
        };
        let drained = input.bytes.drain(..offset).as_slice().to_owned();
        let _ = qemu.write_mem(x1, &drained);
        println!("drained: {:?}", drained);
        SyscallHookResult::new(Some(drained.len() as u64))
    }
    else{
        SyscallHookResult::new(None)
    }
}

impl<I, S> EmulatorModule<I, S> for QemuInputHelper
where
    I: HasTargetBytes + Unpin,
    S: Unpin,
{
    fn post_qemu_init<ET>(&mut self, _qemu: Qemu, emulator_modules: &mut EmulatorModules<ET, I, S>)//hook input syscall
    where
        ET: EmulatorModuleTuple<I, S>,
    {
        emulator_modules.pre_syscalls(Hook::Function(syscall_hook::<ET, I, S>));
    }

    fn pre_exec<ET>(
        &mut self,
        _qemu: Qemu,
        _emulator_modules: &mut EmulatorModules<ET, I, S>,
        _state: &mut S,
        input: &I,
    ) where
        ET: EmulatorModuleTuple<I, S>,
    {
        self.bytes.clear();
        self.bytes.extend_from_slice(input.target_bytes().as_slice());
    }
}

fn main(){
    let aflpp = env::var("__AFL_SHM_ID").is_ok();// get AFL++
    
    let mut args: Vec<String> = env::args().collect();
    
    let seed_file = &args.clone()[1];

    let file = File::open(seed_file);
    let mut seed = Vec::new();
    let _ = file.expect("Error").read_to_end(&mut seed);

    let input = BytesInput::new(seed.clone());

    args.remove(1);
    let modules = tuple_list!(QemuInputHelper::new(seed),);
    let emulator: Emulator<(), NopCommandManager, NopEmulatorDriver, (QemuInputHelper, ()), BytesInput, (), NopSnapshotManager>
     = Emulator::empty()
     .qemu_parameters(args)
     .modules(modules)
     .build().unwrap();
    let qemu = emulator.qemu(); // create emulator

    /*let mut elf_buffer = Vec::new();
    let elf = EasyElf::from_file(qemu.binary_path(), &mut elf_buffer).unwrap();

    let entry_point = elf
        .entry_point(qemu.load_addr())
        .expect("Entry point not found");

    qemu.set_breakpoint(entry_point);
    unsafe { let _ = qemu.run(); };
    qemu.remove_breakpoint(entry_point); // load process

    let mut allow_list = vec![];
    for region in qemu.mappings() {
        if let Some(path) = region.path() {
            if path.contains(qemu.binary_path()) {
                allow_list.push(region.start()..region.end());
                // println!("Instrument {:?} {:#x}-{:#x}", path, region.start(), region.end());
            }
        }
    } // libs info
*/
    if aflpp { map_shared_memory(); }

    //println!("input: {:?}", input);
    let test_harness = |_input: &BytesInput| {
        unsafe {
            //println!("input: {:?}", qemuinput.bytes);
            let _ = qemu.run(); 
        };
        ExitKind::Ok
    };

    // combine AFL++ and LibAFL QEMU
    
    if aflpp {start_forkserver();}

    test_harness(&input);
}


/*
fn emula() -> Result<(), Error>{
    let args: Vec<String> = env::args().collect();
    
    let modules = tuple_list!();
    let emulator: Emulator<(), NopCommandManager, NopEmulatorDriver, (), (), (), NopSnapshotManager>
     = Emulator::empty()
     .qemu_parameters(args)
     .modules(modules)
     .build()?;
    let qemu = emulator.qemu();

    //let mut elf_buffer = Vec::new();
    //let elf = EasyElf::from_file(qemu.binary_path(), &mut elf_buffer).unwrap();
    //let entry_point = elf
    //    .entry_point(qemu.load_addr())
    //    .expect("Entry point not found");

    unsafe{
        match qemu.run() {
            Ok(QemuExitReason::End(_)) => {},
            _ => panic!("Unexpected QEMU exit"),
        }
    }

    return Ok(());
}*/